var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = TraceArrays","category":"page"},{"location":"#TraceArrays","page":"Home","title":"TraceArrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TraceArrays.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [TraceArrays]","category":"page"},{"location":"#TraceArrays.AbstractFourierTraceArray","page":"Home","title":"TraceArrays.AbstractFourierTraceArray","text":"AbstractFourierTraceArray <: AbstractFourierTrace\n\nThe abstract AbstractFourierTraceArray type is the supertype for trace array types which are in the frequency (Fourier) domain.\n\n\n\n\n\n","category":"type"},{"location":"#TraceArrays.AbstractTraceArray","page":"Home","title":"TraceArrays.AbstractTraceArray","text":"AbstractTraceArray <: Seis.AbstractTrace\n\nThe abstract AbstractTraceArray type is the supertype for types which correspond to sets of recordings of seismic data which are, strictly interpreted, 'arrays'.  This means that all sensors have a common time base and are of the same kind (i.e., have the same response).\n\nThe data underlying AbstractTraceArrays is usually stored as a matrix with each column containing a continuous time series of data, and each row representing the same time point at each array element (although the exact implementation of AbstractTraceArray subtype need not be exactly like this).\n\nIndexing (getindex)\n\nIndexing into a AbstractTraceArray with a single index gives you a single Trace back; single-dimension slicing gives you a vector of Traces.\n\nnote: Note\nIn a future version of TraceArrays (or when it is merged into Seis.jl) slicing will instead return a new AbstractTraceArray.\n\nRequired fields\n\nSubtypes of AbstractTraceArray should have at least the following fields:\n\nb: Time in s relative to the origin time (if any) set in evt.time\ndelta: Sampling interval in s\nevt::Event: Event relating to these data.  .evt.time is the time to which .b is relative.\nsta::AbstractVector{<:Station}: Set of stations, one for each channel\ndata::AbstractMatrix: Data, where each column holds a single channel\npicks::Seis.SeisDict{Union{Int,Symbol}, Seis.Pick{T}}: Set of picks, where any one pick represents a single time across all channels.\nmeta::Seis.SeisDict{Symbol,Any}: Metadata for all channels.\n\nRequired methods\n\nempty(::T) where {T<:AbstractTraceArray}: Constructor for a new empty AbstractTraceArray where all fields are deepcopyed apart from .data. This is intended to be used to implement copying functions (e.g., Seis.decimate) which do not need to first copy the whole .data field.\n\nFallback methods\n\nThe following are defined for all AbstractTraceArrays, based on their containing the above fields:\n\nSeis.trace(::AbstractTraceArray)::AbstractMatrix: The data matrix\nSeis.nsamples(::AbstractTraceArray)::Int: Number of samples\nSeis.times(::AbstractTraceArray): Range giving times of each sample\nBase.eltype(::AbstractTraceArray)::DataType: Element type of data matrix\nBase.length(::AbstractTraceArray)::Int: Number of channels\nBase.getindex(::AbstractTraceArray, i::Int)::AbstractTrace\nBase.getindex(::AbstractTraceArray, indices)::AbstractVector{<:AbstractTrace}\nBase.getindex(::AbstractTraceArray, ::Colon)::AbstractVector{<:AbstractTrace}\nBase.firstindex(::AbstractTraceArray)\nBase.lastindex(::AbstractTraceArray)\n(Base.empty(::T) where {T<:AbstractTraceArray})::T\n_check_abstracttracearray_consistency(::AbstractTraceArray, ::Vararg{AbstractTraceArray}): Whether two or more arrays can be append!ed or vcatted together.\n\nGenerated Base functions\n\n== and hash are defined recursively on the fields of subtypes of AbstractTraceArray.  These can be overloaded if needed.\n\n\n\n\n\n","category":"type"},{"location":"#TraceArrays.DASArray","page":"Home","title":"TraceArrays.DASArray","text":"DASArray{T,M,P<:Seis.Position} <: AbstractTraceArray\n\nAbstractTraceArray holding DAS data.\n\nThis type differs from TraceArray in that it records the information on gauge (channel) spacing and distance, which is useful for some things.\n\n\n\nDASArray(; kwargs...)\n\nReturn a new, empty object for DAS data.  Individual fields may be defined using keyword arguments.\n\nnote: Note\nThe keyword argument constructor for DASArrays is not a stable part of the API and may change.\n\nKeyword arguments\n\ndata: AbstractMatrix of data, where columns contain continuous evenly-sampled recordings at each distance, and each column is recorded a constant distance from the last.  These columns therefore correspond to the gauges used in DAS recordings.  The number of channels (columns) is used to create the correct number of stations in the .sta field.\nstarting_distace: Distance from the interrogator of the first channel (m)\ndistance_spacing: Spacing between channels (m)\nb: Start time (relative to .evt.time) of the first sample (s)\ndelta: Sampling interval (s)\n\n\n\n\n\n","category":"type"},{"location":"#TraceArrays.DASArray-Tuple{AbstractArray{<:AbstractTrace}, Any, Any}","page":"Home","title":"TraceArrays.DASArray","text":"DASArray(array_of_traces::AbstractArray{<:AbstractTrace}, starting_distance, distance_spacing)\n\nConstruct a DASArray from an array of single-channel traces, providing the distance to the first channel in m as starting_distance, and the channel spacing in m as distance_spacing.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays.DASArray-Tuple{FebusTools.FebusData}","page":"Home","title":"TraceArrays.DASArray","text":"DASArray(t::FebusTools.FebusData)\n\nConstruct a DASArray from data read from a Febus A1 interrogator.\n\nInstrument metadata is placed in the trace's .meta.febus field. Note that some metadata items (such as :Extent) are not modified from the file read, and so may not be in sync with the data returned.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays.DASArray-Tuple{TraceArrays.AbstractTraceArray, Any, Any}","page":"Home","title":"TraceArrays.DASArray","text":"DASArray(::AbstractTraceArray, starting_distance, distance_spacing) -> ::DASArray\n\nConstruct a DASArray from another kind of AbstractTraceArray (like a TraceArray).  Supply the distance of the first channel in m as starting_distance and the channel spacing in distance_spacing, also in m.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays.DASArray-Union{Tuple{DASArray{T0, M0, P0}}, Tuple{P0}, Tuple{M0}, Tuple{T0}} where {T0, M0, P0}","page":"Home","title":"TraceArrays.DASArray","text":"DASArray(t::DASArray{T,M,P}; kwargs...) -> t′\n\nCreate a new DASArray from an existing one, but where the trace data is replaced by data.  The data matrix type (M parameter in the DASArray type) is replaced by the type of data.\n\nIf the number of columns in data is not the same as the number of channels in t, then the vector of stations in t′.sta is adjusted to be the same length as data.  If there are more channels than before, the t′.sta vector will contain #undef elements where the additional channels are present. Accessing these elements before properly setting them will throw an UndefRefError.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays.FourierDASArray","page":"Home","title":"TraceArrays.FourierDASArray","text":"FourierDASArray <: AbstractFourierTraceArray\n\nThe Fourier transform of a DASArray.\n\nBecause DASArrays by definition are equally sampled in space along the fibre, FourierDASArrays represent the 2D Fourier transform of the data sampled.  FourierDASArrays contain all the information needed on the original number of samples (in time) and channels (in space). The fields b, delta (frequency spacing in Hz), starting_distance distance_spacing, sta, evt, picks and meta remain part of the public API of the type.\n\nThe usual way to create FourierDASArrays is by calling fft on a DASArray.  To convert back to a DASArray, call ifft\n\nnote: Note\nFourierDASArrays share many fields with the DASArray they came from, including the station and event, plus picks and metadata.  These fields are not copied across, and are instead references to the same Station, Event, and so on.  Therefore, any changes to the FourierDASArray will be reflected in the corresponding DASArray.  To avoid this, do f = fft(deepcopy(t)).\n\n\n\nSee also: DASArray, fft, ifft.\n\n\n\n\n\n","category":"type"},{"location":"#TraceArrays.FourierDASArray-Union{Tuple{}, Tuple{P}, Tuple{M}, Tuple{T}} where {T, M, P}","page":"Home","title":"TraceArrays.FourierDASArray","text":"FourierDASArray(; b, delta, data, nsamples=(2*length(data) - 1), starting_distance, distance_spacing, evt=Event(), sta=Station(), picks=nothing, meta=nothing)\n\nCreate a FourierDASArray directly from a set of Fourier coefficients. Users will usually construct a FourierDASArray by calling fft on a Trace instead of using this constructor.\n\nKeyword arguments\n\nb: The starting time in s of the original recording this frequency domain trace represents.\ndelta: The original sampling interval in s of the equivalent time domain trace.\ndata: An AbstractMatrix{<:Complex} containing the set of Fourier coefficients for this frequency domain trace.  Note that this is a 'one-sided' set, where the first index of the first dimension corresponds to 0 Hz and the final index is the Nyquist frequency.  This is because DASArrays represent real quantities.  In the second dimension, the first index corresponds to the most negative wavenumber, the central index a wavenumber of 0, and the final index the largest wavenumber, where the most negative and largest wavenumbers have the same absolute value.\nnsamples: The number of time domain samples in the origin time domain trace which this frequency domain trace represents.  This allows the FourierDASArray to be converted back to the original DASArray with no loss of the number of points.\nstarting_distance: Distance along cable of the first channel (m).\ndistance_spacing: Spacing between channels along the cable (m).\nevt: An Event which defines the source and origin time for the data. Normally this should be taken from the Trace being used to construct the FourierDASArray.\nsta: A Vector{<:Station} which defines the recording stations for the data. Normally this should be taken from the DASArray being used to construct the FourierDASArray.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays.TraceArray","page":"Home","title":"TraceArrays.TraceArray","text":"TraceArray{T,M,P} <: AbstractTraceArray\n\nTraceArrays are sets of traces which are recorded on a strictly defined array of seismic recorders.  This strict definition requires all channels to have the same response and for all samples to be recorded at the same time across array elements (meaning a uniform sampling interval as well). For a single TraceArray, no channels can be partially present, meaning all start and end on the same sample (although a TraceArray can be constructed from channels where gaps have been filled).\n\n\n\n\n\n","category":"type"},{"location":"#TraceArrays.TraceArray-Tuple{AbstractArray{<:AbstractTrace}}","page":"Home","title":"TraceArrays.TraceArray","text":"TraceArray(array_of_traces) -> ::TraceArray\n\nConstruct a TraceArray from an array of AbstractTraces.\n\nExample\n\njulia> using Seis\n\njulia> TraceArray(filter(is_vertical, sample_data(:regional)))\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays.TraceArray-Tuple{}","page":"Home","title":"TraceArrays.TraceArray","text":"TraceArray(; kwargs...)\n\nReturn a new, empty object for trace array data.  Individual fields may be defined using keyword arguments.\n\nnote: Note\nThe keyword argument constructor for TraceArrays is not a stable part of the API and may change.\n\nKeyword arguments\n\nb: Start time (relative to .evt.time) of the first sample (s)\ndelta: Sampling interval (s)\ndata: AbstractMatrix of data, where columns contain continuous evenly-sampled recordings at each distance, and each column is recorded a constant distance from the last.  These columns therefore correspond to the gauges used in DAS recordings.  The number of channels (columns) is used to create the correct number of stations in the .sta field.\n\n\n\n\n\n","category":"method"},{"location":"#AbstractFFTs.fft-Union{Tuple{DASArray{T, <:AbstractMatrix{TV}, P}}, Tuple{P}, Tuple{TV}, Tuple{T}} where {T, TV, P}","page":"Home","title":"AbstractFFTs.fft","text":"Seis.fft(t::DASArray)\n\nConvert the DAS data t into its equivalent frequency domain data f by performing a Fourier transform.  The object returned is a FourierDASArray.\n\nExample\n\njulia> v_app = 5 # Apparent velocity m/s;\n\njulia> freq = 0.5 # Wave frequency, Hz;\n\njulia> delta = 0.05 # Sampling interval;\n\njulia> distance_spacing = 0.05 # Channel spacing, m;\n\njulia> t = DASArray(;\n           b=0, delta, starting_distance=0, distance_spacing,\n           data=sin.(2π*freq.*((0:201).*delta .- (0:201)'.*distance_spacing./v_app))\n       ); # Sine wave of frequency 1 Hz with apparent velocity of 5 m/s;\n\njulia> T = fft(t);\n\njulia> indmax = argmax(abs.(trace(T))) # Get index of maximum power\nCartesianIndex(6, 101)\n\njulia> f = frequencies(T)[indmax[1]] # Maximum frequency in Hz is ~1 as expected\n0.495049504950495\n\njulia> wavenumbers(T) # Wavenumbers corresponding to second dimension of `trace(f)`\n-9.999999999999998:0.099009900990099:9.900990099009901\n\njulia> λ⁻¹ = -wavenumbers(T)[indmax[2]] # Wavenumber of wave in m⁻¹ is -1/-5 ≈ 0.2 as expected\n0.09900990099009732\n\njulia> f/λ⁻¹ # Wave velocity is frequency over wavenumber; ~5 m/s as expected\n5.000000000000084\n\nSee also: ifft.\n\n\n\n\n\n","category":"method"},{"location":"#Base.append!-Tuple{TraceArrays.AbstractTraceArray, Vararg{TraceArrays.AbstractTraceArray}}","page":"Home","title":"Base.append!","text":"append!(a::AbstractTraceArray, rest::AbstractTraceArray...; merge_meta=true) -> a\n\nAppend the traces in rest to a, requiring that they all have consistent start times, sampling rates and trace lengths.\n\nMetadata are merged together by default (unless merge_meta is false). If any entries of the same name occur in both, then those in a are used in preference; otherwise later entries in the argument list are kept.\n\n\n\n\n\n","category":"method"},{"location":"#Base.empty-Tuple{T} where T<:TraceArrays.AbstractTraceArray","page":"Home","title":"Base.empty","text":"empty(t::T) where {T<:AbstractTraceArray} -> t′::T\n\nCreate a copy of an AbstractTraceArray t where all fields apart from the underlying trace data are copied to a new instance of T using Base.deepcopy.\n\nThis function is not exported and is meant to be used by library code to efficiently implement in- and out-of-place processing functions.\n\nt′.data is set to be a 0×nchannels, matrix.  It is the caller's responsibility to ensure that the matrix is set to be consistent with the other internal fields (chiefly .sta) before t′ is used further.\n\n\n\n\n\n","category":"method"},{"location":"#Base.reverse!-Tuple{TraceArrays.AbstractTraceArray}","page":"Home","title":"Base.reverse!","text":"reverse!(t::AbstractTraceArray) -> t\n\nReverse the order of the channels in t.\n\n\n\n\n\n","category":"method"},{"location":"#Base.vcat-Tuple{TraceArrays.AbstractTraceArray, Vararg{TraceArrays.AbstractTraceArray}}","page":"Home","title":"Base.vcat","text":"Base.vcat(a::AbstractTraceArray, rest::AbstractTraceArray...; merge_meta=true)\n\nAppend the traces in rest to a, requiring that they both have consistent start times, sampling rates and trace lengths, returning copies.\n\nMetadata are merged together by default (unless merge_meta is false). If any entries of the same name occur, then those in a are used in preference; otherwise later entries in the argument list are kept.\n\n\n\n\n\n","category":"method"},{"location":"#Seis.integrate!","page":"Home","title":"Seis.integrate!","text":"Seis.integrate!(t::AbstractTraceArray, method=:trapezium) -> t\n\nIntegrate each channel in t, replacing the underlying data with a copy.\n\n\n\n\n\n","category":"function"},{"location":"#Seis.normalise!","page":"Home","title":"Seis.normalise!","text":"normalise!(t::AbstractTraceArray, val=1; all=false) -> t\n\nNormalise all channels in t to have maximum absolute value val.\n\nBy default, this is done on a channel-by-channel basis. To normalise all channels simultaneously, preserving the inter-channel relative amplitudes, use all=true.  In this case, the single maximum absolute amplitude across all the data will be normalised to val instead.\n\n\n\n\n\n","category":"function"},{"location":"#Seis.remove_trend!-Tuple{TraceArrays.AbstractTraceArray}","page":"Home","title":"Seis.remove_trend!","text":"Seis.remove_trend!(t::AbstractTraceArray)\n\nRemove the linear trend from all channels of t, where the trend is found by fitting a straight line to the linear stack of all channels.\n\n\n\n\n\n","category":"method"},{"location":"#Seis.taper!","page":"Home","title":"Seis.taper!","text":"Seis.taper!(t::AbstractTraceArray, width=0.05; form=:hanning)\n\nTaper all channels in t with a taper of width, which is a fraction of the whole trace between 0 and 0.5.\n\n\n\n\n\n","category":"function"},{"location":"#TraceArrays._average_channel_positions-Tuple{AbstractArray{<:Station}, Any}","page":"Home","title":"TraceArrays._average_channel_positions","text":"_average_channel_positions(stas::AbstractArray{<:Seis.Station}, points) -> pos::Vector{<:Seis.Position}\n\nReturn a vector of positions which are the average channel positions for a points-point finite difference differentiation in space.  pos will be shorter than stas due to the differentiation.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays._average_position-Union{Tuple{T}, Tuple{Seis.Geographic{T}, Seis.Geographic{T}}} where T","page":"Home","title":"TraceArrays._average_position","text":"_average_position(a::Seis.Position, b::Seis.Position) -> pos\n\nReturn the mean position of a and b obtained by simple averaging of each coordinate separately.  This is fine for Seis.Cartesian, but may be bad for Seis.Geographic if a and b are far apart.  A warning is thrown in that case.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays._check_abstracttracearray_consistency-Tuple{Any}","page":"Home","title":"TraceArrays._check_abstracttracearray_consistency","text":"_check_abstracttracearray_consistency(ts)\n\nFunction which should throw if any AbstractTraceArrays cannot be sensible merged together with vcat or append.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays._check_trace_consistency-Tuple{NTuple{N, TraceArrays.AbstractTraceArray} where N}","page":"Home","title":"TraceArrays._check_trace_consistency","text":"_check_trace_consistency(ts::NTuple{N,AbstractTraceArray} where N)\n\nThrow an error if the traces in ts cannot be sensibly joined together into a new AbstractTraceArray with vcat or append!.\n\nNew subtypes of AbstractTraceArray may implement methods for this function which impose additional checks on whether all the items in ts are compatible with each other.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays._differentiate-NTuple{4, Any}","page":"Home","title":"TraceArrays._differentiate","text":"_differentiate(data, points, b, delta) -> data′, b\n\nDifferentiate the matrix data along its columns, assuming each column is an evenly-sampled series with spacing delta starting at b seconds. Return the differentiated matrix data′ and new start time b′.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays._integrate!-NTuple{4, Any}","page":"Home","title":"TraceArrays._integrate!","text":"_integrate!(U, u, spacing_by_2, n) -> U\n\nIntegrate the values of u using an n-point trapezium rule, putting the output into U.  U must be the correct size, i.e., it must have n - 1 points fewer than u.  spacing_by_2 is half the even spacing between points in u.\n\nExample\n\njulia> u = 1:7;\n\njulia> U = similar(u, 5);\n\njulia> TraceArrays._integrate!(U, u, 10/2, 3)\n5-element Vector{Float64}:\n  40.0\n  60.0\n  80.0\n 100.0\n 120.0\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays._integrate_rectangle!-Tuple{AbstractMatrix, Any}","page":"Home","title":"TraceArrays._integrate_rectangle!","text":"_integrate_rectangle!(m::AbstractMatrix, delta) -> m\n\nFor an input matrix m whose columns represent some function evaluated at evenly-spaced points delta apart, replace the columns in m with the integrated values.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays._integrate_trapezium-Tuple{AbstractMatrix, Any}","page":"Home","title":"TraceArrays._integrate_trapezium","text":"_integrate_trapezium(m::AbstractMatrix, delta) -> ∫m\n\nFor an input matrix m whose columns represent some function evaluated at evenly-spaced points delta apart, return an updated matrix ∫m whose columns contain the integrated columns of m.  Note therefore that ∫m has one less row than m.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays._matrix_from_traces-Tuple{AbstractArray{<:AbstractTrace}}","page":"Home","title":"TraceArrays._matrix_from_traces","text":"_matrix_from_traces(array_of_traces) -> ::Matrix, T, M, P\n\nAssuming that all the AbstractTraces in array_of_traces have the same number of samples, sampling rate and start time, construct a matrix of the data where each column contains the samples from the corresponding trace.\n\nAlso return T, M and P, the type parameters for the TraceArray which can be formed with the matrix.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays._normalise_all!-Tuple{AbstractMatrix, Any}","page":"Home","title":"TraceArrays._normalise_all!","text":"_normalise_all!(data, val)\n\nNormalise all columns in data such that the maximum absolute value in the whole matrix is val.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays._normalise_columns!-Tuple{AbstractMatrix, Any}","page":"Home","title":"TraceArrays._normalise_columns!","text":"_normalise_columns!(data::AbstractMatrix, val)\n\nNormalise all columns in data to have the maximum absolute value val.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays.cut_distance!-Tuple{DASArray, Any, Any}","page":"Home","title":"TraceArrays.cut_distance!","text":"cut_distance!(t::DASArray, x1, x2; warn=true, allowempty=false) -> t\n\nCut out channels in the DASArray t which lie between distances x1 m and x2 m.  Only channels which are at exactly x1 m or more, and exactly x2 m or less are retained.\n\nIf allowempty is true, then an empty DASArray can be returned when x1 and x2 are either both below or above the cable distance range. Otherwise, an error is thrown.\n\nBy default, warnings are printed if x1 or x2 lie outside the existing range of distances for t and the start or end distance is used instead to perform the cut.  Use warn=false to turn these warnings off.\n\nSee also: cut_distance.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays.cut_distance-Union{Tuple{P}, Tuple{M}, Tuple{T}, Tuple{DASArray{T, M, P}, Any, Any}} where {T, M, P}","page":"Home","title":"TraceArrays.cut_distance","text":"cut_distance(t::DASArray, x1, x2; warn=true, allowempty=false) -> t′\n\nOut-of-place version of cut_distance!.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays.decimate_distance!-Tuple{DASArray, Integer}","page":"Home","title":"TraceArrays.decimate_distance!","text":"decimate_distance!(t::DASArray, n::Integer) -> t\n\nNaively decimate the channels in t, taking every nth channel and removing the rest.  The data field of t is a copy of the data originally used, and the original data array is left untouched.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays.decimate_distance-Tuple{DASArray, Integer}","page":"Home","title":"TraceArrays.decimate_distance","text":"decimate_distance(t::DASArray, n::Integer) -> t\n\nCopying version of decimate_distance.\n\nSee also: decimate_distance.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays.differentiate_distance!-Tuple{DASArray}","page":"Home","title":"TraceArrays.differentiate_distance!","text":"differentiate_distance!(t::DASArray; points::Integer=2) -> t\n\nIn-place version of differentiate_distance.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays.differentiate_distance-Tuple{DASArray}","page":"Home","title":"TraceArrays.differentiate_distance","text":"differentiate_distance(t::DASArray; points::Integer=2) -> t′\n\nDifferentiate the data in t with respect to distance along the cable using points-point finite differencing.\n\nIf data are in units of strain, they are converted to be proportional to units of length-squared.  No unit conversion is made, so data which are in nanostrain convert to nm², nanostrain per second go to nm²/s, and so on.\n\nThe number of channels is reduced in the operation, and each channels coordinates are averaged in the new trace.\n\nAvailable algorithms\n\n(Pseudocode descriptions below drop the time index for clarity.)\n\npoints == 2: Two-point. t′.data[i] = (t.data[i+1] - t.data[i])/t.distance_spacing. Non-central difference, so t.starting_distance is increased by half t.distance_spacing. The number of channels is reduced by 1.\npoints == 3: Three-point. t′.data[i] = (t.data[i+1] - t.data[i-1])/(2 * t.distance_spacing). Central difference.  t.starting_distance is increased by t.distance_spacing; the number of channels is reduced by 2.\npoints == 5: Five-point. `t′.data[i] =   (2/3)*(t.data[i+1] - t.data[i-1])/t.distance_spacing\n(1/12)*(t.data[i+2] - t.data[i-2])/t.distance_spacing`,\nexcept for the first and last points, which use a three-point central difference meaning only two points fewer are retained as for points == 3. Central difference.  t.starting_distance is increased by t.distance_spacing; number of channels reduced by 2.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays.distances-Tuple{DASArray}","page":"Home","title":"TraceArrays.distances","text":"distances(da::DASArray) -> dists\n\nReturn a range giving the distances in m along the fibre of each channel in da.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays.integrate_distance","page":"Home","title":"TraceArrays.integrate_distance","text":"integrate_distance(t::DASArray, n=3) -> t′\n\nIntegrate the data in t with respect to distance along the cable.  If data are in units of strain, therefore, they are converted to units of displacement (and similarly for strain rate to velocity).  No unit conversion is made, so data which are in nanostrain convert to nm, and likewise nanostrain/s becomes nm/s.\n\nn determines how many points are used in the integration and must be an odd number.  This determines the number of points used for the trapezoidal integration.\n\nThe number of channels is reduced by n - 1.  For example, when n is 3, t′ has 2 fewer channels than before, and the first and last channels in t are removed from t′.\n\nExample\n\njulia> t = DASArray(; data=[0. 1 0 -1; 1 2 -2 1], b=0, delta=1, starting_distance=0, distance_spacing=0.5);\n\njulia> integrate_distance(t)\n2×2 Matrix{Float64}:\n 0.5    0.0\n 0.75  -0.25\n\n\n\n\n\n","category":"function"},{"location":"#TraceArrays.nwavenumbers-Tuple{FourierDASArray}","page":"Home","title":"TraceArrays.nwavenumbers","text":"nwavenumbers(f::FourierDASArray) -> n\n\nReturn the number of wavenumbers in the frequency-domain DAS array f which are distinct only in terms of magnitude.  For a trace array with original length N, this is N÷2 + 1.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays.plot_heatmap","page":"Home","title":"TraceArrays.plot_heatmap","text":"plot_heatmap([gridposition,] t::DASArray; figure=(), axis(), kwargs...)\nplot_heatmap([gridposition,] t::FourierDASArray; figure=(), axis(), kwargs...)\n\nPlot the trace values of a DASArray, or the absolute values of a FourierDASArray's coefficients, in terms of frequency and wavenumber on via Makie.heatmap.\n\nIf the first argument is a grid position (Makie.GridPosition or Makie.GridSubposition), then a new axis is created at that point within the layout.  Keyword arguments to the Makie.Axis constructor can be passed as a named tuple in axis.  This method returns a Makie.AxisPlot which can be iterated to retrieve the axis handle and plot handle.\n\nWithout a grid position, a new figure is created, in which case the figure keyword argument can be used to pass a named tuple of keyword arguments to the Makie.Figure constructor. This method returns a Makie.FigureAxisPlot containing handles to all three of the figure, axis and plot object.\n\nRemaining keyword arguments kwargs are passed to the call to Makie.heatmap.\n\nThis function can only be used after loading a Makie backend, e.g. by doing using GLMakie, using CairoMakie, and so on.\n\n\n\n\n\n","category":"function"},{"location":"#TraceArrays.plot_heatmap!","page":"Home","title":"TraceArrays.plot_heatmap!","text":"plot_heatmap!(axis::Makie.Axis, t::FourierDASArray; kwargs...)\n\nPlot the trace values of a DASArray, or the absolute values of a FourierDASArray's coefficients, in terms of frequency and wavenumber on via Makie.heatmap.  The plot is added to an existing Makie.Axis axis.  kwargs are passed to Makie.heatmap.\n\nThis function can only be used after loading a Makie backend, e.g. by doing using GLMakie, using CairoMakie, and so on.\n\n\n\n\n\n","category":"function"},{"location":"#TraceArrays.read_febus-Tuple{Any}","page":"Home","title":"TraceArrays.read_febus","text":"read_febus(file; kwargs...) -> ::DASArray{Float64, Matrix{Float32}, Seis.Geographic{Float64}}\n\nRead DAS data from file in the Febus HDF5 format.\n\nKeyword arguments\n\nxlim=(-Inf, Inf): Read only a range of distances (m)\nxdecimate=1: Decimate the number of channels read in.\ntlim=(-146138511-01-01T00:00:00, 146138512-12-31T23:59:59): Read data between two DateTimes\nblocks=(1,nblocks): Read in only data blocks within the given range. (Data blocks are typically 1 s long, but can be any length.)\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays.remove_median_trace!-Tuple{TraceArrays.AbstractTraceArray}","page":"Home","title":"TraceArrays.remove_median_trace!","text":"remove_median_trace!(t::AbstractTraceArray) -> t\n\nRemove the median trace from all channels in t.\n\nThe operation finds the median value at each time sample across all channels and subtracts this from all channels, modifying the original trace.\n\nSee also remove_median_trace.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays.remove_median_trace-Tuple{TraceArrays.AbstractTraceArray}","page":"Home","title":"TraceArrays.remove_median_trace","text":"remove_median_trace(t::AbstractTraceArray) -> t′\n\nOut-of-place version of remove_median_trace!.\n\n\n\n\n\n","category":"method"},{"location":"#TraceArrays.wavenumbers-Tuple{FourierDASArray}","page":"Home","title":"TraceArrays.wavenumbers","text":"wavenumbers(f::FourierDASArray)\n\nReturn the wavenumbers (spatial frequencies) of the Fourier-domain DAS array f for each point of the second dimension of the underlying trace data obtained with trace(f).  The units are m⁻¹, i.e., there is no factor of 2π.\n\n\n\n\n\n","category":"method"}]
}
