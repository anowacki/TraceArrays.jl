<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · TraceArrays.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://anowacki.github.io/TraceArrays.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TraceArrays.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/anowacki/TraceArrays.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TraceArrays"><a class="docs-heading-anchor" href="#TraceArrays">TraceArrays</a><a id="TraceArrays-1"></a><a class="docs-heading-anchor-permalink" href="#TraceArrays" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/anowacki/TraceArrays.jl">TraceArrays</a>.</p><ul><li><a href="#TraceArrays.AbstractFourierTraceArray"><code>TraceArrays.AbstractFourierTraceArray</code></a></li><li><a href="#TraceArrays.AbstractTraceArray"><code>TraceArrays.AbstractTraceArray</code></a></li><li><a href="#TraceArrays.DASArray-Tuple{AbstractArray{&lt;:AbstractTrace}, Any, Any}"><code>TraceArrays.DASArray</code></a></li><li><a href="#TraceArrays.DASArray-Tuple{FebusTools.FebusData}"><code>TraceArrays.DASArray</code></a></li><li><a href="#TraceArrays.DASArray"><code>TraceArrays.DASArray</code></a></li><li><a href="#TraceArrays.DASArray-Union{Tuple{DASArray{T0, M0, P0}}, Tuple{P0}, Tuple{M0}, Tuple{T0}} where {T0, M0, P0}"><code>TraceArrays.DASArray</code></a></li><li><a href="#TraceArrays.DASArray-Tuple{TraceArrays.AbstractTraceArray, Any, Any}"><code>TraceArrays.DASArray</code></a></li><li><a href="#TraceArrays.FourierDASArray-Union{Tuple{}, Tuple{P}, Tuple{M}, Tuple{T}} where {T, M, P}"><code>TraceArrays.FourierDASArray</code></a></li><li><a href="#TraceArrays.FourierDASArray"><code>TraceArrays.FourierDASArray</code></a></li><li><a href="#TraceArrays.TraceArray"><code>TraceArrays.TraceArray</code></a></li><li><a href="#TraceArrays.TraceArray-Tuple{AbstractArray{&lt;:AbstractTrace}}"><code>TraceArrays.TraceArray</code></a></li><li><a href="#TraceArrays.TraceArray-Tuple{}"><code>TraceArrays.TraceArray</code></a></li><li><a href="#AbstractFFTs.fft-Union{Tuple{DASArray{T, &lt;:AbstractMatrix{TV}, P}}, Tuple{P}, Tuple{TV}, Tuple{T}} where {T, TV, P}"><code>AbstractFFTs.fft</code></a></li><li><a href="#Base.append!-Tuple{TraceArrays.AbstractTraceArray, Vararg{TraceArrays.AbstractTraceArray}}"><code>Base.append!</code></a></li><li><a href="#Base.empty-Tuple{T} where T&lt;:TraceArrays.AbstractTraceArray"><code>Base.empty</code></a></li><li><a href="#Base.reverse!-Tuple{TraceArrays.AbstractTraceArray}"><code>Base.reverse!</code></a></li><li><a href="#Base.vcat-Tuple{TraceArrays.AbstractTraceArray, Vararg{TraceArrays.AbstractTraceArray}}"><code>Base.vcat</code></a></li><li><a href="#Seis.integrate!"><code>Seis.integrate!</code></a></li><li><a href="#Seis.normalise!"><code>Seis.normalise!</code></a></li><li><a href="#Seis.remove_trend!-Tuple{TraceArrays.AbstractTraceArray}"><code>Seis.remove_trend!</code></a></li><li><a href="#Seis.taper!"><code>Seis.taper!</code></a></li><li><a href="#TraceArrays._average_channel_positions-Tuple{AbstractArray{&lt;:Station}, Any}"><code>TraceArrays._average_channel_positions</code></a></li><li><a href="#TraceArrays._average_position-Union{Tuple{T}, Tuple{Seis.Geographic{T}, Seis.Geographic{T}}} where T"><code>TraceArrays._average_position</code></a></li><li><a href="#TraceArrays._check_abstracttracearray_consistency-Tuple{Any}"><code>TraceArrays._check_abstracttracearray_consistency</code></a></li><li><a href="#TraceArrays._check_trace_consistency-Tuple{NTuple{N, TraceArrays.AbstractTraceArray} where N}"><code>TraceArrays._check_trace_consistency</code></a></li><li><a href="#TraceArrays._differentiate-NTuple{4, Any}"><code>TraceArrays._differentiate</code></a></li><li><a href="#TraceArrays._integrate!-NTuple{4, Any}"><code>TraceArrays._integrate!</code></a></li><li><a href="#TraceArrays._integrate_rectangle!-Tuple{AbstractMatrix, Any}"><code>TraceArrays._integrate_rectangle!</code></a></li><li><a href="#TraceArrays._integrate_trapezium-Tuple{AbstractMatrix, Any}"><code>TraceArrays._integrate_trapezium</code></a></li><li><a href="#TraceArrays._matrix_from_traces-Tuple{AbstractArray{&lt;:AbstractTrace}}"><code>TraceArrays._matrix_from_traces</code></a></li><li><a href="#TraceArrays._normalise_all!-Tuple{AbstractMatrix, Any}"><code>TraceArrays._normalise_all!</code></a></li><li><a href="#TraceArrays._normalise_columns!-Tuple{AbstractMatrix, Any}"><code>TraceArrays._normalise_columns!</code></a></li><li><a href="#TraceArrays.cut_distance-Union{Tuple{P}, Tuple{M}, Tuple{T}, Tuple{DASArray{T, M, P}, Any, Any}} where {T, M, P}"><code>TraceArrays.cut_distance</code></a></li><li><a href="#TraceArrays.cut_distance!-Tuple{DASArray, Any, Any}"><code>TraceArrays.cut_distance!</code></a></li><li><a href="#TraceArrays.decimate_distance-Tuple{DASArray, Integer}"><code>TraceArrays.decimate_distance</code></a></li><li><a href="#TraceArrays.decimate_distance!-Tuple{DASArray, Integer}"><code>TraceArrays.decimate_distance!</code></a></li><li><a href="#TraceArrays.differentiate_distance-Tuple{DASArray}"><code>TraceArrays.differentiate_distance</code></a></li><li><a href="#TraceArrays.differentiate_distance!-Tuple{DASArray}"><code>TraceArrays.differentiate_distance!</code></a></li><li><a href="#TraceArrays.distances-Tuple{DASArray}"><code>TraceArrays.distances</code></a></li><li><a href="#TraceArrays.integrate_distance"><code>TraceArrays.integrate_distance</code></a></li><li><a href="#TraceArrays.nwavenumbers-Tuple{FourierDASArray}"><code>TraceArrays.nwavenumbers</code></a></li><li><a href="#TraceArrays.read_febus-Tuple{Any}"><code>TraceArrays.read_febus</code></a></li><li><a href="#TraceArrays.remove_median_trace-Tuple{TraceArrays.AbstractTraceArray}"><code>TraceArrays.remove_median_trace</code></a></li><li><a href="#TraceArrays.remove_median_trace!-Tuple{TraceArrays.AbstractTraceArray}"><code>TraceArrays.remove_median_trace!</code></a></li><li><a href="#TraceArrays.wavenumbers-Tuple{FourierDASArray}"><code>TraceArrays.wavenumbers</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.AbstractFourierTraceArray" href="#TraceArrays.AbstractFourierTraceArray"><code>TraceArrays.AbstractFourierTraceArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFourierTraceArray &lt;: AbstractFourierTrace</code></pre><p>The abstract <code>AbstractFourierTraceArray</code> type is the supertype for trace array types which are in the frequency (Fourier) domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/abstract.jl#L230-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.AbstractTraceArray" href="#TraceArrays.AbstractTraceArray"><code>TraceArrays.AbstractTraceArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractTraceArray &lt;: Seis.AbstractTrace</code></pre><p>The abstract <code>AbstractTraceArray</code> type is the supertype for types which correspond to sets of recordings of seismic data which are, strictly interpreted, &#39;arrays&#39;.  This means that all sensors have a common time base and are of the same kind (i.e., have the same response).</p><p>The data underlying <code>AbstractTraceArray</code>s is usually stored as a matrix with each column containing a continuous time series of data, and each row representing the same time point at each array element (although the exact implementation of <code>AbstractTraceArray</code> subtype need not be exactly like this).</p><p><strong>Indexing (<code>getindex</code>)</strong></p><p>Indexing into a <code>AbstractTraceArray</code> with a single index gives you a single <code>Trace</code> back; single-dimension slicing gives you a vector of <code>Trace</code>s.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In a future version of TraceArrays (or when it is merged into Seis.jl) slicing will instead return a new <code>AbstractTraceArray</code>.</p></div></div><p><strong>Required fields</strong></p><p>Subtypes of <code>AbstractTraceArray</code> should have at least the following fields:</p><ul><li><code>b</code>: Time in s relative to the origin time (if any) set in <code>evt.time</code></li><li><code>delta</code>: Sampling interval in s</li><li><code>evt::Event</code>: Event relating to these data.  <code>.evt.time</code> is the time to which <code>.b</code> is relative.</li><li><code>sta::AbstractVector{&lt;:Station}</code>: Set of stations, one for each channel</li><li><code>data::AbstractMatrix</code>: Data, where each column holds a single channel</li><li><code>picks::Seis.SeisDict{Union{Int,Symbol}, Seis.Pick{T}}</code>: Set of picks, where any one pick represents a single time across all channels.</li><li><code>meta::Seis.SeisDict{Symbol,Any}</code>: Metadata for all channels.</li></ul><p><strong>Required methods</strong></p><ul><li><code>empty(::T) where {T&lt;:AbstractTraceArray}</code>: Constructor for a new empty <code>AbstractTraceArray</code> where all fields are <code>deepcopy</code>ed apart from <code>.data</code>. This is intended to be used to implement copying functions (e.g., <code>Seis.decimate</code>) which do not need to first copy the whole <code>.data</code> field.</li></ul><p><strong>Fallback methods</strong></p><p>The following are defined for all <code>AbstractTraceArray</code>s, based on their containing the above fields:</p><ul><li><code>Seis.trace(::AbstractTraceArray)::AbstractMatrix</code>: The data matrix</li><li><code>Seis.nsamples(::AbstractTraceArray)::Int</code>: Number of samples</li><li><code>Seis.times(::AbstractTraceArray)</code>: Range giving times of each sample</li><li><code>Base.eltype(::AbstractTraceArray)::DataType</code>: Element type of data matrix</li><li><code>Base.length(::AbstractTraceArray)::Int</code>: Number of channels</li><li><code>Base.getindex(::AbstractTraceArray, i::Int)::AbstractTrace</code></li><li><code>Base.getindex(::AbstractTraceArray, indices)::AbstractVector{&lt;:AbstractTrace}</code></li><li><code>Base.getindex(::AbstractTraceArray, ::Colon)::AbstractVector{&lt;:AbstractTrace}</code></li><li><code>Base.firstindex(::AbstractTraceArray)</code></li><li><code>Base.lastindex(::AbstractTraceArray)</code></li><li><code>(Base.empty(::T) where {T&lt;:AbstractTraceArray})::T</code></li><li><code>_check_abstracttracearray_consistency(::AbstractTraceArray, ::Vararg{AbstractTraceArray})</code>: Whether two or more arrays can be <code>append!</code>ed or <code>vcat</code>ted together.</li></ul><p><strong>Generated <code>Base</code> functions</strong></p><p><code>==</code> and <code>hash</code> are defined recursively on the fields of subtypes of <code>AbstractTraceArray</code>.  These can be overloaded if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/abstract.jl#L3-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.DASArray" href="#TraceArrays.DASArray"><code>TraceArrays.DASArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DASArray{T,M,P&lt;:Seis.Position} &lt;: AbstractTraceArray</code></pre><p><code>AbstractTraceArray</code> holding DAS data.</p><p>This type differs from <code>TraceArray</code> in that it records the information on gauge (channel) spacing and distance, which is useful for some things.</p><hr/><pre><code class="nohighlight hljs">DASArray(; kwargs...)</code></pre><p>Return a new, empty object for DAS data.  Individual fields may be defined using keyword arguments.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The keyword argument constructor for <code>DASArray</code>s is not a stable part of the API and may change.</p></div></div><p><strong>Keyword arguments</strong></p><ul><li><code>data</code>: <code>AbstractMatrix</code> of data, where columns contain continuous evenly-sampled recordings at each distance, and each column is recorded a constant distance from the last.  These columns therefore correspond to the gauges used in DAS recordings.  The number of channels (columns) is used to create the correct number of stations in the <code>.sta</code> field.</li><li><code>starting_distace</code>: Distance from the interrogator of the first channel (m)</li><li><code>distance_spacing</code>: Spacing between channels (m)</li><li><code>b</code>: Start time (relative to <code>.evt.time</code>) of the first sample (s)</li><li><code>delta</code>: Sampling interval (s)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/dasarray.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.DASArray-Tuple{AbstractArray{&lt;:AbstractTrace}, Any, Any}" href="#TraceArrays.DASArray-Tuple{AbstractArray{&lt;:AbstractTrace}, Any, Any}"><code>TraceArrays.DASArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DASArray(array_of_traces::AbstractArray{&lt;:AbstractTrace}, starting_distance, distance_spacing)</code></pre><p>Construct a <code>DASArray</code> from an array of single-channel traces, providing the distance to the first channel in m as <code>starting_distance</code>, and the channel spacing in m as <code>distance_spacing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/dasarray.jl#L133-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.DASArray-Tuple{FebusTools.FebusData}" href="#TraceArrays.DASArray-Tuple{FebusTools.FebusData}"><code>TraceArrays.DASArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DASArray(t::FebusTools.FebusData)</code></pre><p>Construct a <code>DASArray</code> from data read from a Febus A1 interrogator.</p><p>Instrument metadata is placed in the trace&#39;s <code>.meta.febus</code> field. Note that some metadata items (such as <code>:Extent</code>) are not modified from the file read, and so may not be in sync with the data returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/dasarray.jl#L91-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.DASArray-Tuple{TraceArrays.AbstractTraceArray, Any, Any}" href="#TraceArrays.DASArray-Tuple{TraceArrays.AbstractTraceArray, Any, Any}"><code>TraceArrays.DASArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DASArray(::AbstractTraceArray, starting_distance, distance_spacing) -&gt; ::DASArray</code></pre><p>Construct a <code>DASArray</code> from another kind of <code>AbstractTraceArray</code> (like a <code>TraceArray</code>).  Supply the distance of the first channel in m as <code>starting_distance</code> and the channel spacing in <code>distance_spacing</code>, also in m.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/dasarray.jl#L114-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.DASArray-Union{Tuple{DASArray{T0, M0, P0}}, Tuple{P0}, Tuple{M0}, Tuple{T0}} where {T0, M0, P0}" href="#TraceArrays.DASArray-Union{Tuple{DASArray{T0, M0, P0}}, Tuple{P0}, Tuple{M0}, Tuple{T0}} where {T0, M0, P0}"><code>TraceArrays.DASArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DASArray(t::DASArray{T,M,P}; kwargs...) -&gt; t′</code></pre><p>Create a new <code>DASArray</code> from an existing one, but where the trace data is replaced by <code>data</code>.  The data matrix type (<code>M</code> parameter in the <code>DASArray</code> type) is replaced by the type of <code>data</code>.</p><p>If the number of columns in <code>data</code> is not the same as the number of channels in <code>t</code>, then the vector of stations in <code>t′.sta</code> is adjusted to be the same length as <code>data</code>.  If there are more channels than before, the <code>t′.sta</code> vector will contain <code>#undef</code> elements where the additional channels are present. Accessing these elements before properly setting them will throw an <code>UndefRefError</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/dasarray.jl#L60-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.FourierDASArray" href="#TraceArrays.FourierDASArray"><code>TraceArrays.FourierDASArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FourierDASArray &lt;: AbstractFourierTraceArray</code></pre><p>The Fourier transform of a <a href="#TraceArrays.DASArray"><code>DASArray</code></a>.</p><p>Because <code>DASArray</code>s by definition are equally sampled in space along the fibre, <code>FourierDASArrays</code> represent the 2D Fourier transform of the data sampled.  <code>FourierDASArray</code>s contain all the information needed on the original number of samples (in time) and channels (in space). The fields <code>b</code>, <code>delta</code> (frequency spacing in Hz), <code>starting_distance</code> <code>distance_spacing</code>, <code>sta</code>, <code>evt</code>, <code>picks</code> and <code>meta</code> remain part of the public API of the type.</p><p>The usual way to create <code>FourierDASArray</code>s is by calling <a href="#AbstractFFTs.fft-Union{Tuple{DASArray{T, &lt;:AbstractMatrix{TV}, P}}, Tuple{P}, Tuple{TV}, Tuple{T}} where {T, TV, P}"><code>fft</code></a> on a <code>DASArray</code>.  To convert back to a <code>DASArray</code>, call <a href="@ref"><code>ifft</code></a></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>FourierDASArray</code>s share many fields with the <code>DASArray</code> they came from, including the station and event, plus picks and metadata.  These fields are <strong>not</strong> copied across, and are instead references to the same <code>Station</code>, <code>Event</code>, and so on.  Therefore, any changes to the <code>FourierDASArray</code> will be reflected in the corresponding <code>DASArray</code>.  To avoid this, do <code>f = fft(deepcopy(t))</code>.</p></div></div><hr/><p>See also: <a href="#TraceArrays.DASArray"><code>DASArray</code></a>, <a href="#AbstractFFTs.fft-Union{Tuple{DASArray{T, &lt;:AbstractMatrix{TV}, P}}, Tuple{P}, Tuple{TV}, Tuple{T}} where {T, TV, P}"><code>fft</code></a>, <a href="@ref"><code>ifft</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/fourierdasarray.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.FourierDASArray-Union{Tuple{}, Tuple{P}, Tuple{M}, Tuple{T}} where {T, M, P}" href="#TraceArrays.FourierDASArray-Union{Tuple{}, Tuple{P}, Tuple{M}, Tuple{T}} where {T, M, P}"><code>TraceArrays.FourierDASArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FourierDASArray(; b, delta, data, nsamples=(2*length(data) - 1), starting_distance, distance_spacing, evt=Event(), sta=Station(), picks=nothing, meta=nothing)</code></pre><p>Create a <code>FourierDASArray</code> directly from a set of Fourier coefficients. Users will usually construct a <code>FourierDASArray</code> by calling <a href="#AbstractFFTs.fft-Union{Tuple{DASArray{T, &lt;:AbstractMatrix{TV}, P}}, Tuple{P}, Tuple{TV}, Tuple{T}} where {T, TV, P}"><code>fft</code></a> on a <code>Trace</code> instead of using this constructor.</p><p><strong>Keyword arguments</strong></p><ul><li><code>b</code>: The starting time in s of the original recording this frequency domain trace represents.</li><li><code>delta</code>: The <strong>original sampling interval in s</strong> of the equivalent time domain trace.</li><li><code>data</code>: An <code>AbstractMatrix{&lt;:Complex}</code> containing the set of Fourier coefficients for this frequency domain trace.  Note that this is a &#39;one-sided&#39; set, where the first index of the first dimension corresponds to 0 Hz and the final index is the Nyquist frequency.  This is because <code>DASArray</code>s represent real quantities.  In the second dimension, the first index corresponds to the most negative wavenumber, the central index a wavenumber of 0, and the final index the largest wavenumber, where the most negative and largest wavenumbers have the same absolute value.</li><li><code>nsamples</code>: The number of time domain samples in the origin time domain trace which this frequency domain trace represents.  This allows the <code>FourierDASArray</code> to be converted back to the original <code>DASArray</code> with no loss of the number of points.</li><li><code>starting_distance</code>: Distance along cable of the first channel (m).</li><li><code>distance_spacing</code>: Spacing between channels along the cable (m).</li><li><code>evt</code>: An <code>Event</code> which defines the source and origin time for the data. Normally this should be taken from the <code>Trace</code> being used to construct the <code>FourierDASArray</code>.</li><li><code>sta</code>: A <code>Vector{&lt;:Station}</code> which defines the recording stations for the data. Normally this should be taken from the <code>DASArray</code> being used to construct the <code>FourierDASArray</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/fourierdasarray.jl#L57-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.TraceArray" href="#TraceArrays.TraceArray"><code>TraceArrays.TraceArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TraceArray{T,M,P} &lt;: AbstractTraceArray</code></pre><p><code>TraceArray</code>s are sets of traces which are recorded on a strictly defined array of seismic recorders.  This strict definition requires all channels to have the same response and for all samples to be recorded at the same time across array elements (meaning a uniform sampling interval as well). For a single <code>TraceArray</code>, no channels can be partially present, meaning all start and end on the same sample (although a <code>TraceArray</code> can be constructed from channels where gaps have been filled).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/tracearray.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.TraceArray-Tuple{AbstractArray{&lt;:AbstractTrace}}" href="#TraceArrays.TraceArray-Tuple{AbstractArray{&lt;:AbstractTrace}}"><code>TraceArrays.TraceArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TraceArray(array_of_traces) -&gt; ::TraceArray</code></pre><p>Construct a <code>TraceArray</code> from an array of <code>AbstractTrace</code>s.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; using Seis

julia&gt; TraceArray(filter(is_vertical, sample_data(:regional)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/tracearray.jl#L56-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.TraceArray-Tuple{}" href="#TraceArrays.TraceArray-Tuple{}"><code>TraceArrays.TraceArray</code></a> — <span class="docstring-category">Method</span></header><section><div><p>TraceArray(; kwargs...)</p><p>Return a new, empty object for trace array data.  Individual fields may be defined using keyword arguments.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The keyword argument constructor for <code>TraceArray</code>s is not a stable part of the API and may change.</p></div></div><p><strong>Keyword arguments</strong></p><ul><li><code>b</code>: Start time (relative to <code>.evt.time</code>) of the first sample (s)</li><li><code>delta</code>: Sampling interval (s)</li><li><code>data</code>: <code>AbstractMatrix</code> of data, where columns contain continuous evenly-sampled recordings at each distance, and each column is recorded a constant distance from the last.  These columns therefore correspond to the gauges used in DAS recordings.  The number of channels (columns) is used to create the correct number of stations in the <code>.sta</code> field.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/tracearray.jl#L22-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.fft-Union{Tuple{DASArray{T, &lt;:AbstractMatrix{TV}, P}}, Tuple{P}, Tuple{TV}, Tuple{T}} where {T, TV, P}" href="#AbstractFFTs.fft-Union{Tuple{DASArray{T, &lt;:AbstractMatrix{TV}, P}}, Tuple{P}, Tuple{TV}, Tuple{T}} where {T, TV, P}"><code>AbstractFFTs.fft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Seis.fft(t::DASArray)</code></pre><p>Convert the DAS data <code>t</code> into its equivalent frequency domain data <code>f</code> by performing a Fourier transform.  The object returned is a <a href="#TraceArrays.FourierDASArray"><code>FourierDASArray</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; v_app = 5 # Apparent velocity m/s;

julia&gt; freq = 0.5 # Wave frequency, Hz;

julia&gt; delta = 0.05 # Sampling interval;

julia&gt; distance_spacing = 0.05 # Channel spacing, m;

julia&gt; t = DASArray(;
           b=0, delta, starting_distance=0, distance_spacing,
           data=sin.(2π*freq.*((0:201).*delta .- (0:201)&#39;.*distance_spacing./v_app))
       ); # Sine wave of frequency 1 Hz with apparent velocity of 5 m/s;

julia&gt; T = fft(t);

julia&gt; indmax = argmax(abs.(trace(T))) # Get index of maximum power
CartesianIndex(6, 101)

julia&gt; f = frequencies(T)[indmax[1]] # Maximum frequency in Hz is ~1 as expected
0.495049504950495

julia&gt; wavenumbers(T) # Wavenumbers corresponding to second dimension of `trace(f)`
-9.999999999999998:0.099009900990099:9.900990099009901

julia&gt; λ⁻¹ = -wavenumbers(T)[indmax[2]] # Wavenumber of wave in m⁻¹ is -1/-5 ≈ 0.2 as expected
0.09900990099009732

julia&gt; f/λ⁻¹ # Wave velocity is frequency over wavenumber; ~5 m/s as expected
5.000000000000084</code></pre><p>See also: <a href="@ref"><code>ifft</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/fourierdasarray.jl#L128-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.append!-Tuple{TraceArrays.AbstractTraceArray, Vararg{TraceArrays.AbstractTraceArray}}" href="#Base.append!-Tuple{TraceArrays.AbstractTraceArray, Vararg{TraceArrays.AbstractTraceArray}}"><code>Base.append!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">append!(a::AbstractTraceArray, rest::AbstractTraceArray...; merge_meta=true) -&gt; a</code></pre><p>Append the traces in <code>rest</code> to <code>a</code>, requiring that they all have consistent start times, sampling rates and trace lengths.</p><p>Metadata are merged together by default (unless <code>merge_meta</code> is <code>false</code>). If any entries of the same name occur in both, then those in <code>a</code> are used in preference; otherwise later entries in the argument list are kept.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/abstract.jl#L110-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.empty-Tuple{T} where T&lt;:TraceArrays.AbstractTraceArray" href="#Base.empty-Tuple{T} where T&lt;:TraceArrays.AbstractTraceArray"><code>Base.empty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">empty(t::T) where {T&lt;:AbstractTraceArray} -&gt; t′::T</code></pre><p>Create a copy of an <code>AbstractTraceArray</code> <code>t</code> where all fields apart from the underlying trace data are copied to a new instance of <code>T</code> using <code>Base.deepcopy</code>.</p><p>This function is not exported and is meant to be used by library code to efficiently implement in- and out-of-place processing functions.</p><p><code>t′.data</code> is set to be a 0×nchannels, matrix.  It is the caller&#39;s responsibility to ensure that the matrix is set to be consistent with the other internal fields (chiefly <code>.sta</code>) before <code>t′</code> is used further.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/abstract.jl#L138-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse!-Tuple{TraceArrays.AbstractTraceArray}" href="#Base.reverse!-Tuple{TraceArrays.AbstractTraceArray}"><code>Base.reverse!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reverse!(t::AbstractTraceArray) -&gt; t</code></pre><p>Reverse the order of the channels in <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/operations.jl#L244-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.vcat-Tuple{TraceArrays.AbstractTraceArray, Vararg{TraceArrays.AbstractTraceArray}}" href="#Base.vcat-Tuple{TraceArrays.AbstractTraceArray, Vararg{TraceArrays.AbstractTraceArray}}"><code>Base.vcat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.vcat(a::AbstractTraceArray, rest::AbstractTraceArray...; merge_meta=true)</code></pre><p>Append the traces in <code>rest</code> to <code>a</code>, requiring that they both have consistent start times, sampling rates and trace lengths, returning copies.</p><p>Metadata are merged together by default (unless <code>merge_meta</code> is <code>false</code>). If any entries of the same name occur, then those in <code>a</code> are used in preference; otherwise later entries in the argument list are kept.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/abstract.jl#L161-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.integrate!" href="#Seis.integrate!"><code>Seis.integrate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Seis.integrate!(t::AbstractTraceArray, method=:trapezium) -&gt; t</code></pre><p>Integrate each channel in <code>t</code>, replacing the underlying data with a copy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/operations.jl#L106-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.normalise!" href="#Seis.normalise!"><code>Seis.normalise!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalise!(t::AbstractTraceArray, val=1; all=false) -&gt; t</code></pre><p>Normalise all channels in <code>t</code> to have maximum absolute value <code>val</code>.</p><p>By default, this is done on a channel-by-channel basis. To normalise all channels simultaneously, preserving the inter-channel relative amplitudes, use <code>all=true</code>.  In this case, the single maximum absolute amplitude across all the data will be normalised to <code>val</code> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/operations.jl#L180-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.remove_trend!-Tuple{TraceArrays.AbstractTraceArray}" href="#Seis.remove_trend!-Tuple{TraceArrays.AbstractTraceArray}"><code>Seis.remove_trend!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Seis.remove_trend!(t::AbstractTraceArray)</code></pre><p>Remove the linear trend from all channels of <code>t</code>, where the trend is found by fitting a straight line to the linear stack of all channels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/operations.jl#L229-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Seis.taper!" href="#Seis.taper!"><code>Seis.taper!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Seis.taper!(t::AbstractTraceArray, width=0.05; form=:hanning)</code></pre><p>Taper all channels in <code>t</code> with a taper of <code>width</code>, which is a fraction of the whole trace between 0 and 0.5.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/operations.jl#L257-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays._average_channel_positions-Tuple{AbstractArray{&lt;:Station}, Any}" href="#TraceArrays._average_channel_positions-Tuple{AbstractArray{&lt;:Station}, Any}"><code>TraceArrays._average_channel_positions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_average_channel_positions(stas::AbstractArray{&lt;:Seis.Station}, points) -&gt; pos::Vector{&lt;:Seis.Position}</code></pre><p>Return a vector of positions which are the average channel positions for a <code>points</code>-point finite difference differentiation in space.  <code>pos</code> will be shorter than <code>stas</code> due to the differentiation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/dasarray.jl#L350-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays._average_position-Union{Tuple{T}, Tuple{Seis.Geographic{T}, Seis.Geographic{T}}} where T" href="#TraceArrays._average_position-Union{Tuple{T}, Tuple{Seis.Geographic{T}, Seis.Geographic{T}}} where T"><code>TraceArrays._average_position</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_average_position(a::Seis.Position, b::Seis.Position) -&gt; pos</code></pre><p>Return the mean position of <code>a</code> and <code>b</code> obtained by simple averaging of each coordinate separately.  This is fine for <code>Seis.Cartesian</code>, but may be bad for <code>Seis.Geographic</code> if <code>a</code> and <code>b</code> are far apart.  A warning is thrown in that case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/dasarray.jl#L370-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays._check_abstracttracearray_consistency-Tuple{Any}" href="#TraceArrays._check_abstracttracearray_consistency-Tuple{Any}"><code>TraceArrays._check_abstracttracearray_consistency</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_check_abstracttracearray_consistency(ts)</code></pre><p>Function which should throw if any <code>AbstractTraceArrays</code> cannot be sensible merged together with <code>vcat</code> or <code>append</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/abstract.jl#L203-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays._check_trace_consistency-Tuple{NTuple{N, TraceArrays.AbstractTraceArray} where N}" href="#TraceArrays._check_trace_consistency-Tuple{NTuple{N, TraceArrays.AbstractTraceArray} where N}"><code>TraceArrays._check_trace_consistency</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_check_trace_consistency(ts::NTuple{N,AbstractTraceArray} where N)</code></pre><p>Throw an error if the traces in <code>ts</code> cannot be sensibly joined together into a new <code>AbstractTraceArray</code> with <a href="#Base.vcat-Tuple{TraceArrays.AbstractTraceArray, Vararg{TraceArrays.AbstractTraceArray}}"><code>vcat</code></a> or <a href="@ref Base.append(::AbstractTraceArray, ::Vararg{AbstractTraceArray})"><code>append!</code></a>.</p><p>New subtypes of <code>AbstractTraceArray</code> may implement methods for this function which impose additional checks on whether all the items in <code>ts</code> are compatible with each other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/abstract.jl#L188-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays._differentiate-NTuple{4, Any}" href="#TraceArrays._differentiate-NTuple{4, Any}"><code>TraceArrays._differentiate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_differentiate(data, points, b, delta) -&gt; data′, b</code></pre><p>Differentiate the matrix <code>data</code> along its columns, assuming each column is an evenly-sampled series with spacing <code>delta</code> starting at <code>b</code> seconds. Return the differentiated matrix <code>data′</code> and new start time <code>b′</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/operations.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays._integrate!-NTuple{4, Any}" href="#TraceArrays._integrate!-NTuple{4, Any}"><code>TraceArrays._integrate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_integrate!(U, u, spacing_by_2, n) -&gt; U</code></pre><p>Integrate the values of <code>u</code> using an <code>n</code>-point trapezium rule, putting the output into <code>U</code>.  <code>U</code> must be the correct size, i.e., it must have <code>n - 1</code> points fewer than <code>u</code>.  <code>spacing_by_2</code> is half the even spacing between points in <code>u</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; u = 1:7;

julia&gt; U = similar(u, 5);

julia&gt; TraceArrays._integrate!(U, u, 10/2, 3)
5-element Vector{Float64}:
  40.0
  60.0
  80.0
 100.0
 120.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/dasarray.jl#L447-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays._integrate_rectangle!-Tuple{AbstractMatrix, Any}" href="#TraceArrays._integrate_rectangle!-Tuple{AbstractMatrix, Any}"><code>TraceArrays._integrate_rectangle!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_integrate_rectangle!(m::AbstractMatrix, delta) -&gt; m</code></pre><p>For an input matrix <code>m</code> whose columns represent some function evaluated at evenly-spaced points <code>delta</code> apart, replace the columns in <code>m</code> with the integrated values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/operations.jl#L164-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays._integrate_trapezium-Tuple{AbstractMatrix, Any}" href="#TraceArrays._integrate_trapezium-Tuple{AbstractMatrix, Any}"><code>TraceArrays._integrate_trapezium</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_integrate_trapezium(m::AbstractMatrix, delta) -&gt; ∫m</code></pre><p>For an input matrix <code>m</code> whose columns represent some function evaluated at evenly-spaced points <code>delta</code> apart, return an updated matrix <code>∫m</code> whose columns contain the integrated columns of <code>m</code>.  Note therefore that <code>∫m</code> has one less row than <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/operations.jl#L141-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays._matrix_from_traces-Tuple{AbstractArray{&lt;:AbstractTrace}}" href="#TraceArrays._matrix_from_traces-Tuple{AbstractArray{&lt;:AbstractTrace}}"><code>TraceArrays._matrix_from_traces</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_matrix_from_traces(array_of_traces) -&gt; ::Matrix, T, M, P</code></pre><p>Assuming that all the <code>AbstractTrace</code>s in <code>array_of_traces</code> have the same number of samples, sampling rate and start time, construct a matrix of the data where each column contains the samples from the corresponding trace.</p><p>Also return <code>T</code>, <code>M</code> and <code>P</code>, the type parameters for the <code>TraceArray</code> which can be formed with the matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/tracearray.jl#L92-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays._normalise_all!-Tuple{AbstractMatrix, Any}" href="#TraceArrays._normalise_all!-Tuple{AbstractMatrix, Any}"><code>TraceArrays._normalise_all!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_normalise_all!(data, val)</code></pre><p>Normalise all columns in <code>data</code> such that the maximum absolute value in the whole matrix is <code>val</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/operations.jl#L215-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays._normalise_columns!-Tuple{AbstractMatrix, Any}" href="#TraceArrays._normalise_columns!-Tuple{AbstractMatrix, Any}"><code>TraceArrays._normalise_columns!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_normalise_columns!(data::AbstractMatrix, val)</code></pre><p>Normalise all columns in <code>data</code> to have the maximum absolute value <code>val</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/operations.jl#L200-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.cut_distance!-Tuple{DASArray, Any, Any}" href="#TraceArrays.cut_distance!-Tuple{DASArray, Any, Any}"><code>TraceArrays.cut_distance!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cut_distance!(t::DASArray, x1, x2; warn=true, allowempty=false) -&gt; t</code></pre><p>Cut out channels in the <code>DASArray</code> <code>t</code> which lie between distances <code>x1</code> m and <code>x2</code> m.  Only channels which are at exactly <code>x1</code> m or more, and exactly <code>x2</code> m or less are retained.</p><p>If <code>allowempty</code> is <code>true</code>, then an empty <code>DASArray</code> can be returned when <code>x1</code> and <code>x2</code> are either both below or above the cable distance range. Otherwise, an error is thrown.</p><p>By default, warnings are printed if <code>x1</code> or <code>x2</code> lie outside the existing range of distances for <code>t</code> and the start or end distance is used instead to perform the cut.  Use <code>warn=false</code> to turn these warnings off.</p><p>See also: <a href="#TraceArrays.cut_distance-Union{Tuple{P}, Tuple{M}, Tuple{T}, Tuple{DASArray{T, M, P}, Any, Any}} where {T, M, P}"><code>cut_distance</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/dasarray.jl#L176-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.cut_distance-Union{Tuple{P}, Tuple{M}, Tuple{T}, Tuple{DASArray{T, M, P}, Any, Any}} where {T, M, P}" href="#TraceArrays.cut_distance-Union{Tuple{P}, Tuple{M}, Tuple{T}, Tuple{DASArray{T, M, P}, Any, Any}} where {T, M, P}"><code>TraceArrays.cut_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cut_distance(t::DASArray, x1, x2; warn=true, allowempty=false) -&gt; t′</code></pre><p>Out-of-place version of <a href="#TraceArrays.cut_distance!-Tuple{DASArray, Any, Any}"><code>cut_distance!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/dasarray.jl#L202-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.decimate_distance!-Tuple{DASArray, Integer}" href="#TraceArrays.decimate_distance!-Tuple{DASArray, Integer}"><code>TraceArrays.decimate_distance!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decimate_distance!(t::DASArray, n::Integer) -&gt; t</code></pre><p>Naively decimate the channels in <code>t</code>, taking every <code>n</code>th channel and removing the rest.  The data field of <code>t</code> is a copy of the data originally used, and the original data array is left untouched.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/dasarray.jl#L246-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.decimate_distance-Tuple{DASArray, Integer}" href="#TraceArrays.decimate_distance-Tuple{DASArray, Integer}"><code>TraceArrays.decimate_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decimate_distance(t::DASArray, n::Integer) -&gt; t</code></pre><p>Copying version of <a href="#TraceArrays.decimate_distance-Tuple{DASArray, Integer}"><code>decimate_distance</code></a>.</p><p>See also: <a href="#TraceArrays.decimate_distance-Tuple{DASArray, Integer}"><code>decimate_distance</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/dasarray.jl#L260-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.differentiate_distance!-Tuple{DASArray}" href="#TraceArrays.differentiate_distance!-Tuple{DASArray}"><code>TraceArrays.differentiate_distance!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">differentiate_distance!(t::DASArray; points::Integer=2) -&gt; t</code></pre><p>In-place version of <a href="#TraceArrays.differentiate_distance-Tuple{DASArray}"><code>differentiate_distance</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/dasarray.jl#L338-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.differentiate_distance-Tuple{DASArray}" href="#TraceArrays.differentiate_distance-Tuple{DASArray}"><code>TraceArrays.differentiate_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">differentiate_distance(t::DASArray; points::Integer=2) -&gt; t′</code></pre><p>Differentiate the data in <code>t</code> with respect to distance along the cable using <code>points</code>-point finite differencing.</p><p>If data are in units of strain, they are converted to be proportional to units of length-squared.  No unit conversion is made, so data which are in nanostrain convert to nm², nanostrain per second go to nm²/s, and so on.</p><p>The number of channels is reduced in the operation, and each channels coordinates are averaged in the new trace.</p><p><strong>Available algorithms</strong></p><p>(Pseudocode descriptions below drop the time index for clarity.)</p><ul><li><code>points == 2</code>: Two-point. <code>t′.data[i] = (t.data[i+1] - t.data[i])/t.distance_spacing</code>. Non-central difference, so <code>t.starting_distance</code> is increased by half <code>t.distance_spacing</code>. The number of channels is reduced by 1.</li><li><code>points == 3</code>: Three-point. <code>t′.data[i] = (t.data[i+1] - t.data[i-1])/(2 * t.distance_spacing)</code>. Central difference.  <code>t.starting_distance</code> is increased by <code>t.distance_spacing</code>; the number of channels is reduced by 2.</li><li><code>points == 5</code>: Five-point. `t′.data[i] =   (2/3)*(t.data[i+1] - t.data[i-1])/t.distance_spacing<ul><li>(1/12)*(t.data[i+2] - t.data[i-2])/t.distance_spacing`,</li></ul>except for the first and last points, which use a three-point central difference meaning only two points fewer are retained as for <code>points == 3</code>. Central difference.  <code>t.starting_distance</code> is increased by <code>t.distance_spacing</code>; number of channels reduced by 2.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/dasarray.jl#L274-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.distances-Tuple{DASArray}" href="#TraceArrays.distances-Tuple{DASArray}"><code>TraceArrays.distances</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distances(da::DASArray) -&gt; dists</code></pre><p>Return a range giving the distances in m along the fibre of each channel in <code>da</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/dasarray.jl#L144-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.integrate_distance" href="#TraceArrays.integrate_distance"><code>TraceArrays.integrate_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrate_distance(t::DASArray, n=3) -&gt; t′</code></pre><p>Integrate the data in <code>t</code> with respect to distance along the cable.  If data are in units of strain, therefore, they are converted to units of displacement (and similarly for strain rate to velocity).  No unit conversion is made, so data which are in nanostrain convert to nm, and likewise nanostrain/s becomes nm/s.</p><p><code>n</code> determines how many points are used in the integration and must be an odd number.  This determines the number of points used for the trapezoidal integration.</p><p>The number of channels is reduced by <code>n - 1</code>.  For example, when <code>n</code> is 3, <code>t′</code> has 2 fewer channels than before, and the first and last channels in <code>t</code> are removed from <code>t′</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; t = DASArray(; data=[0. 1 0 -1; 1 2 -2 1], b=0, delta=1, starting_distance=0, distance_spacing=0.5);

julia&gt; integrate_distance(t)
2×2 Matrix{Float64}:
 0.5    0.0
 0.75  -0.25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/dasarray.jl#L388-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.nwavenumbers-Tuple{FourierDASArray}" href="#TraceArrays.nwavenumbers-Tuple{FourierDASArray}"><code>TraceArrays.nwavenumbers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nwavenumbers(f::FourierDASArray) -&gt; n</code></pre><p>Return the number of wavenumbers in the frequency-domain DAS array <code>f</code> which are distinct only in terms of magnitude.  For a trace array with original length <code>N</code>, this is <code>N÷2 + 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/fourierdasarray.jl#L224-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.read_febus-Tuple{Any}" href="#TraceArrays.read_febus-Tuple{Any}"><code>TraceArrays.read_febus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_febus(file; kwargs...) -&gt; ::DASArray{Float64, Matrix{Float32}, Seis.Geographic{Float64}}</code></pre><p>Read DAS data from <code>file</code> in the Febus HDF5 format.</p><p><strong>Keyword arguments</strong></p><ul><li><code>xlim=(-Inf, Inf)</code>: Read only a range of distances (m)</li><li><code>xdecimate=1</code>: Decimate the number of channels read in.</li><li><code>tlim=(-146138511-01-01T00:00:00, 146138512-12-31T23:59:59)</code>: Read data between two <code>DateTime</code>s</li><li><code>blocks=(1,nblocks)</code>: Read in only data blocks within the given range. (Data blocks are typically 1 s long, but can be any length.)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/dasarray.jl#L151-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.remove_median_trace!-Tuple{TraceArrays.AbstractTraceArray}" href="#TraceArrays.remove_median_trace!-Tuple{TraceArrays.AbstractTraceArray}"><code>TraceArrays.remove_median_trace!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_median_trace!(t::AbstractTraceArray) -&gt; t</code></pre><p>Remove the median trace from all channels in <code>t</code>.</p><p>The operation finds the median value at each time sample across all channels and subtracts this from all channels, modifying the original trace.</p><p>See also <a href="#TraceArrays.remove_median_trace-Tuple{TraceArrays.AbstractTraceArray}"><code>remove_median_trace</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/filtering.jl#L103-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.remove_median_trace-Tuple{TraceArrays.AbstractTraceArray}" href="#TraceArrays.remove_median_trace-Tuple{TraceArrays.AbstractTraceArray}"><code>TraceArrays.remove_median_trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_median_trace(t::AbstractTraceArray) -&gt; t′</code></pre><p>Out-of-place version of <a href="#TraceArrays.remove_median_trace!-Tuple{TraceArrays.AbstractTraceArray}"><code>remove_median_trace!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/filtering.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TraceArrays.wavenumbers-Tuple{FourierDASArray}" href="#TraceArrays.wavenumbers-Tuple{FourierDASArray}"><code>TraceArrays.wavenumbers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wavenumbers(f::FourierDASArray)</code></pre><p>Return the wavenumbers (spatial frequencies) of the Fourier-domain DAS array <code>f</code> for each point of the second dimension of the underlying trace data obtained with <code>trace(f)</code>.  The units are m⁻¹, i.e., there is no factor of 2π.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anowacki/TraceArrays.jl/blob/7aa5259da6b0f4fc8851eae1031219f30db58b80/src/fourierdasarray.jl#L233-L240">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 22 August 2025 20:48">Friday 22 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
